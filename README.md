# Ultimate Tic Tac Toe

## Как запустить?

### Linux

0. Если вам не нужны всякие новомодные графические интерфейсы, просто запустите программу в ключом `--nogui`
1. [Установить SFML 2.6](https://www.sfml-dev.org/tutorials/2.6/start-linux.php#installing-sfml)
2. Запустить программу


### Windows

$$\dots$$



## Как скомпилировать?

### Linux

1. [Установить SFML 2.6](https://www.sfml-dev.org/tutorials/2.6/start-linux.php#installing-sfml)
2. Клонировать репозиторий
3. Запустить `compile_linux.sh`


### Windows

1. Скачать [WinLibs MSVCRT 13.1.0 (64-bit)](https://github.com/brechtsanders/winlibs_mingw/releases/download/13.1.0-16.0.5-11.0.0-msvcrt-r5/winlibs-x86_64-posix-seh-gcc-13.1.0-mingw-w64msvcrt-11.0.0-r5.7z) (спецефичиские компиляторы) с [сайта sfml](https://www.sfml-dev.org/download/sfml/2.6.1/)

2. Добавить путь к исполняемому файлу программы (добавляйте путь к папке, в которой лежит компилятор g++, он должен быть в архиве, доступным по ссылке из пункта 1 (mingw64/bin/)) в переменную среды PATH:

    1. Найдите путь к исполняемому файлу программы. Обычно он находится в папке, где установлена программа, и имеет расширение .exe.

    2. Откройте Панель управления.

    4. В разделе "Переменные среды пользователя" найдите переменную PATH и нажмите на кнопку "Изменить".

    5. В окне "Измененить переменную среды" нажмите на кнопку "Создать" и введите путь к папке с исполняемым файлом программы.

    6. Нажмите "ОК" во всех открытых окнах, чтобы сохранить изменения.

3. Клонировать репозиторий.

3. Скачать [GCC 13.1.0 MinGW (SEH) - 64-bit](https://www.sfml-dev.org/files/SFML-2.6.1-windows-gcc-13.1.0-mingw-64-bit.zip) с официального [сайта sfml](https://www.sfml-dev.org/download/sfml/2.6.1/).

4. Далее используй файлы из предыдущего пункта скомпилируйте как знаете..., можете использовать этот [туториал](https://www.sfml-dev.org/tutorials/2.6/start-linux.php#installing-sfml) и основываться на файле `compile_windows.cmd`


## Правила
[Правила из википедии](https://en.wikipedia.org/wiki/Ultimate_tic-tac-toe#Rules)

Первый / второй игрок - крестик / нолик.

Действия игры происходят на поле размером 9 на 9 клеток. Поле разбивается на 9 блоков (далее - **блок**) размером 3 на 3 каждый.

Первый ходит в любую клетку.

далее ходят второй и первый по очереди:

1. определить, в какую клетку в **блоке** попал предыдущий игрок (0 - 8),

2. сделать ход в **блоке** с тем же индексом, что и ячейка **блока** предыдущего игрока, если данный **блок** не *помечен*.
    - если же данный **блок** *помечен*, текущий игрок будет должен походить в любую клетку в любом *непомеченном* **блоке**.

Если в каком-либо **блоке** происходит победа первого,вторго игрока, или ничья, он *помечается* как победный для первого, втоорого игрока, или ничейный.

Побеждает тот, кто первым достигнет состояния поля, при котором из **блоков** будет видно, кто победил по обычным правилам игры в крестики-нолики.

## Движок игры

### Трансформации поля

трансформации поля нужны для ускорения поиска ходов, ведь нету разницы между ходом в левый верхний угол и ходом в правыйнижний например.

каждую из восьми трансформаций (поворот и отражения) можно описать с помощью матриц! 

удобно для создания аглгоритма поиска индекса рассортировать матрицы так, как показано ниже:

индекс | матрица | описание трансформации
-|-|-
000 | $$\begin{bmatrix} 1& 0 \\\  0& 1\end{bmatrix}$$ | без изменений
001 | $$\begin{bmatrix}-1& 0 \\\  0& 1\end{bmatrix}$$ | отражение по вертикали
010 | $$\begin{bmatrix} 1& 0 \\\  0&-1\end{bmatrix}$$ | отражение по горизонтали
011 | $$\begin{bmatrix}-1& 0 \\\  0&-1\end{bmatrix}$$ | поворот на $$180\degree$$
100 | $$\begin{bmatrix} 0& 1 \\\  1& 0\end{bmatrix}$$ | отражение относительно прямой $$y=x$$
101 | $$\begin{bmatrix} 0&-1 \\\  1& 0\end{bmatrix}$$ | поворот против часовой стрелки на $$90\degree$$
110 | $$\begin{bmatrix} 0& 1 \\\ -1& 0\end{bmatrix}$$ | поворот по часовой стрелке на $$90\degree$$
111 | $$\begin{bmatrix} 0&-1 \\\ -1& 0\end{bmatrix}$$ | отражение относительно прямой $$y=-x$$

здесь третий бит отвечает за расположение единиц по побочной / главной диагонали

второй бит за знак последних двух элементов матрицы ( - / + )

первый бит за знак первых двух элементов матрицы ( - / + )